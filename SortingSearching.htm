<!DOCTYPE html>
<html>
<head>
<title>Sophia's Portfolio: Unit 3 (Sorting and Searching) </title>
<style>
body 
{
  text-align: center;
  background-image: url("rainforest.JPG");
}
h1 
{
  font-family: "Lucida Sans Unicode", "Lucida Grande", sans-serif;
  font-size: 450%;
  color: white;
  text-align: center;
  letter-spacing: 3px;
}
h3
{
  font-family: "Lucida Sans Unicode", "Lucida Grande", sans-serif;
  font-size: 125%;
  color: white;
  text-align: left;
  letter-spacing: 1.5px;
  font-weight: bold;
}
h4
{
  font-family: "Lucida Sans Unicode", "Lucida Grande", sans-serif;
  font-size: 100%;
  color: white;
  text-align: left;
  letter-spacing: 1.5px;
  font-weight: bold;
}
div 
{
  width: auto;
  border: 5px solid white;
  border-color : #145A32;
  padding: 25px;
  margin: auto;
  background-color:#1D8348;
}
p
{
  font-family: "Lucida Sans Unicode", "Lucida Grande", sans-serif;
  font-size: 100%;
  color: white;
  text-align: left;
  letter-spacing: 1.5px;
}
pre
{
  font-family: "Lucida Sans Unicode", "Lucida Grande", sans-serif;
  font-size: 100%;
  color: white;
  text-align: left;
  letter-spacing: 1.5px;
}
.button 
{
	background:linear-gradient(to bottom, #b8e356 5%, #a5cc52 100%);
	background-color:#b8e356;
	border-radius:6px;
	border:1px solid #83c41a;
	display:inline-block;
	cursor:pointer;
	color:#ffffff;
	font-family:Georgia;
	font-size:15px;
	font-weight:bold;
	padding:7px 18.5px;
	text-decoration: none;
	text-shadow:0px 1px 0px #86ae47;
}
.button:hover 
{
	background:linear-gradient(to bottom, #a5cc52 5%, #b8e356 100%);
	background-color:#a5cc52;
}
.button:active 
{
	position:relative;
	top:1px;
}
box 
{
  width: 600px;
  background-color:#D1F2EB;
  margin: 20px;
}
</style>
</head>
<body>
<h1>Unit 3: Sorting and Searching</h1>
<box>
  <centre>
<a href="index.htm" class="button">Homepage</a>
<a href="AboutMe.htm" class="button">About Me</a>
<a href="OOP.htm" class="button">Unit 1: OOP (Part 1)</a>
<a href="Arrays.htm" class="button">Unit 2: Arrays and ArrayLists</a>
<a href="SortingSearching.htm" class="button">Unit 3: Sorting and Searching</a>
<a href="Recursion.htm" class="button">Unit 4: Recursion</a>
<a href="OOP2.htm" class="button">Unit 5: OOP (Part 2)</a>
<a href="PastProjects.htm" class="button">Past Projects</a>
<a href="FutureProjects.htm" class="button">Future Projects</a>
<a href="Bibliography.htm" class="button">Bibliography</a>
</centre>
</box>
<div>
<h3>What Is a Sorting Algorithm?</h3>
<p>A sorting algorithm is a procedure that puts values in a list or array in ascending or descending order. This can either be by numerical order or alphabetical order. 
</p>
<pre>
Sorting Terminology: 
Swapping is replacing two elements’ values with each other in an array. 
A pass is every time a sorting algorithm runs through the array.
</pre>
<h3>What Is a Searching Algorithm?</h3>
<p>A searching algorithm is a procedure that searches a list or array for a specific value.  
</p>
<h3>Efficiency</h3>
<p>The efficiency of an algorithm is how much memory an algorithm needs to perform the task and how long it takes to do the task, which includes comparisons and swapping.    
The best case is the special case that allows the algorithm to be the most efficient.
The worst case is the special case that makes the algorithm the least efficient. The average case is the average efficiency of the algorithm. 
The time complexity of an algorithm is how long it takes to finish its task (measured in Big O Notation).   
The space complexity of an algorithm is how much space it needs to finish its task. It is measured by auxiliary space, which is the extra space used by an algorithm. 
</p>
<h3>Big O Notation</h3>
<p>Big O Notation is a notation for time complexity that describes how many comparisons an algorithm needs to finish sorting or searching, relative to the n, the number of elements.   
</p>
<pre>
Examples of Big O Notation: 
O(n)
O(log n) 
O (n log n)
O(n^2)
O(2^n)
</pre>
<h3>Sequential Search</h3>
<p>Sequential search is a search algorithm that checks each element of the list or array to see if it equals the value. It starts from the first element and runs through the array, returning the index of the element with the value, or returns -1 if the value was not found in the array. The time efficiency is O(n). It is the most efficient when the first element is equal to the value and is least efficient when the last element is equal to the value or the value was not found in the array. 
</p>
<pre>
<code>
Example: 
/*This method performs a sequential search in arr to find value and return the respective index with value.*/
/*It returns -1 if the value was not found*/
public int search (int[]arr, int value)
{
	//loop runs through array 
	for (int i = 0; i < arr.length; i++)
	{
		//if element is equal to the value return the index
		if (arr[i]==value)
			return i; 
	}
	//element not found, so return -1
	return -1; 
}
</code>
</pre>
<h3>Binary Search</h3>
<p>Binary search is a search algorithm that repeatedly checks if the middle index’s value in the array is greater than, less than, or equal to the value. If it is equal, it returns the middle index. Otherwise, it changes its boundaries to less than or greater than the middle index and repeats until the value has been found or the value is not in the array. Binary search requires the array to be sorted in ascending or descending order. Binary search is a divide and conquer algorithm, which means it breaks down the problem into simpler parts to solve. The time efficiency is O(log n). The best case is when the value is in the middle of the array. The worst case is when the value is at the beginning or end of the array, or is not in the array. 
</p>
<pre>
<code>
Example: 
/*This method performs a binary search in arr to find value and return the respective index with value.*/
/*It returns -1 if the value was not found.*/
/*Precondition: arr is sorted in ascending order*/
public int search (int[] arr, int value)
    {
       //sets value of middle to the middle element 
        int middle = (arr.length - 1) / 2;
       //sets value of left to the leftmost element 	
        int left = 0;
       //sets value of right to the rightmost element 
        int right = arr.length - 1;
        //while loop 
        while (left <= right)
        {
           //if middle element equals value, then return the index 
            if (arr [middle] == value)
                return middle;
            //if middle element is greater than value, change right boundary to the left of middle 
            if (arr [middle] > value)
                right = middle - 1;
            //if middle element is less than value, change left boundary to the right of middle 
            if (arr [middle] < value)
                left = middle + 1; 
            //resets middle to middle element of left and right boundary
            middle = (left + right) / 2;
        }
       //value not found in arr, returns -1
        return -1;
    }
</code>
</pre>
<h3>Bubble Sort</h3>
<p>Bubble sort is one of the most simple sorting algorithms. It’s easy to understand and a good introduction to sorting, which will make it easier to learn more complex concepts of sorting. The way bubble sort works is it repeatedly swaps each pair of elements in an array if the order is wrong. Swapping is just replacing two values with each other in an array. 
</p>
<img src="BubbleSort.jpg" alt="Bubble sort"height="500" width="850">
<p>To optimize a bubble sort algorithm, which means to make an algorithm the most efficient it can be, we can stop as soon as the array has been sorted. To do this, we can create a boolean variable called swapped and set it to true in the nested for loop if two elements are swapped. After each pass, which is every time the algorithm passes through the array, we can check if swapped equals to false, which will tell us that the array has been sorted and no swaps were needed, and we can break from the loop. </p>
<pre>
<code>
/*Bubble sort method*/
public int[] sortArray (int [] sort)
{
        //temporary placeholder 
        int temp = 0;
        //variable to keep track of whether variables have been swapped 
        boolean swapped;

        //loops # times = number of elements
        for (int i = 0 ; i < sort.length-1; i++)
        {
            swapped = false; //sets swapped to false 
            //loops from first element to second last element
	    //with each pass, the boundary moves one left due to the last element being the greatest
            for (int x = 0 ; x < sort.length - i - 1 ; x++)
            {
                //compares if x value (first one in pair) is greater than i value (second one in pair)
                if (sort [x] > sort [x+1])
                {
                    //swaps values 
                    temp = sort [x+1];
                    sort [x+1] = sort [x];
                    sort [x] = temp;
                    swapped = true; //sets swapped to true 
                }
            }
            //ends sorting if no values have been swapped
            if (swapped == false)
                break;
        }
        return sort; 
}
</code>
</pre>
<p>The program knows it has finished sorting once the final pass does not need any modifications made to the array. 
</p>
<h4>Efficiency</h4>
<p>The best case scenario is when the elements are already sorted. The worst case scenario is when the array is sorted in reverse order. The worst case and average case time complexity, in big O notation is О(n^2) and this means it takes n * n comparisons to finish, where n is the number of elements. The best case time complexity, when the code is optimized for efficiency, is O(n), and this means it takes n comparisons to finish. Bubble sort has an auxiliary space of 1, which is the temporary variable used in swapping. Overall, bubble sort is not very practical and efficient compared to other sorting algorithms. 
</p>
<h4>When to use bubble sort</h4>
<p>We can use bubble sort for small, nearly-sorted arrays. It is fast when you want to detect small errors or the array is nearly sorted. It is one of the slowest sorting algorithms for random arrays, reversed arrays, and few unique values arrays. It is good when data is small and not good when it’s big. All in all, it’s not a great sorting method to use, but very easy to program so often used as an intro. A real-world use for bubble sort is adding one value to already sorted array. 
</p>
<h3>Selection Sort</h3>
<p>Selection sort is a sorting algorithm that runs through the array, repeatedly finds the maximum or minimum value in the array, and swaps it with that position. The time complexity for selection sort is O(n^2). The space complexity is O(1). The best, average, and worst case are all O(n^2). </p>
<pre>
<code>
Example: 
/*This method sorts the array in descending order.*/
public void sort(int[]arr)
{
	//loop runs each element through the array (except the last element) 
	for (int i = 0; i < arr.length - 1; i++)
	{
		//keeps track of maxIndex 
		int maxIndex = i; 
		//loop runs through the rest of the elements
		for (int x = i+1; x < arr.length; x++)
		{
			//if arr[x] is greater than the max value 
			if (arr[x]>arr[maxIndex])
 			{
				maxIndex = x; 
 			}
		}	 		
		//swap 
		int temp = arr[i]; 
		arr[i] = arr[maxIndex];
		arr[maxIndex] = temp; 
	}
} 
</code>
</pre>
<h3>Insertion Sort</h3>
<p>Insertion sort is a sorting algorithm that runs through the array and inserts the value in its correct position in the sorted part of the array. The time complexity for insertion sort is O(n^2). The space complexity is O(1). The best case is when the elements are already sorted, and the worst case is when the elements are sorted in reverse order.  
</p>
<pre>
<code>
Example:
//sorts in ascending order  
public void sort(int arr[])
{
	//first loop goes from the second element to the last element 
        for (int i = 1; i < arr.length; i++) 
        {
	    //sets key element to each element starting from second to last 
            int key = arr[i];
            //sets an x to keep track of the initial position of the element right before the key, which is the starting point for comparison 
            int x = i - 1;
            //while loop
	    //prevents out of bounds error, stops when it reaches beginning of array and x = -1 
            //compares the x element to the key element, moves if greater
            //keeps checking until the beginning of the array    
            while (x >= 0 && arr[x] > key) 
	    {
                //shifts each element to the right 
                arr[x + 1] = arr[x];
                //moves x position to the left for the next check
                x = x - 1;
            }
            //exits loop when element is not greater than key 
            //inserts key element into the correct position
            arr[x + 1] = key;
        }
}
</code>
</pre>

</div>
</body>
</html>
